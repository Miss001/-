# 基本架构
![image](https://github.com/user-attachments/assets/94eeff51-56ea-4887-95b9-5fd9e0b9b2db)

## 逻辑结构
- 一个Postgresql服务器运行在一个主机(host)上并且管理着一个database cluster。  
- 一个DataBase Cluster可以包括：多个Database、多个User、以及Database中的所有对象。
- 一个Database 可以有多个Schema（数据库中的命名空间），在数据库中创建的所有对象都是在Schema中创建，一个用户可以从同一个客户端连接中访问不同的Schema。不同的Schema中可以有多个同名的表、视图、索引等对象。当创建一个数据库时，会为其创建一个名为public的默认Schema。  
- 每个Database是相互独立的，彼此之间无法直接进行跨库关联查询，需要借助dblink或其他扩展。  
- 每个Database都有自己独立的表和索引文件，表和索引文件的大小限制为1 GB。   
- 每个表都有两个关联文件、后缀分别为 _fsm 和 _vm。它们称为可用空间映射和可见性映射。用于存储有关可用空间容量的信息、并可查看表文件中的每个页面   
- 索引只具有单个可用空间映射、而不具有可见性映射。   
- 所有数据库对象都由各自的OID在内部管理，其OID存储在pg_database中。  
- 表和索引也由各个OID管理，其OID存储在pg_class中。 
```
-- 数据库对应的oid
select * from pg_database ;
-- 表/索引等对应的oid
select * from pg_class  
```
![image](https://github.com/user-attachments/assets/f4840d02-10db-419b-81cc-708b384e5aa6)


## 物理结构
一个database cluster基本上就是作为基础目录(base directory)的一个目录：$PGDATA  
一个database是base子目录下的一个子目录。  
每一个表和索引在base子目录中保存在(至少)一个文件（索引和数据可以保存在一个物理文件中）。  

## 事务
特性：ACID（原子性/一致性/隔离性/持久性）  
默认隔离级别：Read Committed  
- 开启事务  
```
BEGIN TRANSACTION;
BEGIN WORK;
BEGIN;
```
- 提交事务 
```
COMMIT TRANSACTION;
COMMIT WORK;
COMMIT;
```
- 回滚事务  
```
ROLLBACK TRANSACTION;
ROLLBACK WORK;
ROLLBACK;
```
### 子事务（保存点）  
SAVEPOINT（保存点）是一个数据库特性，它允许你在事务中创建命名点，在处理事务中的错误或异常时有选择地回滚到事务中的特定点，而不必撤消到目前为止所做的所有更改。一旦事务结束，保存点的生命周期就结束了，即事务结束后，没有办法回到某个保存点。
示例：
```
CREATE TABLE test0 AS SELECT 1 AS i;
-- Start a main transaction
BEGIN;
-- Perform some operations within the transaction
UPDATE test0 SET i = i + 1;
-- Start a subtransaction
SAVEPOINT s1;
-- Continue with more operations
UPDATE test0 SET i = i - 1000;
-- Check the content in the table
SELECT * FROM test0;
  i
------
 -998
(1 row)
-- Something went wrong, let's roll back to the savepoint
ROLLBACK TO SAVEPOINT s1;
-- Continue with other operations
UPDATE test0 SET i = i + 1;
-- Finally, when everything is fine, commit the transaction
COMMIT;
-- Check the content in the table again
SELECT * FROM test0;
 i
---
 3
(1 row)
```

### 组合事务  
- 一个组合事务 ID 是一个内部标识符，用于支持多个事务的行锁定。
- 当事务使用 “SELECT … FOR UPDATE”（或者是锁定模式：SHARE、KEY SHARE、NO KEY UPDATE）锁定和更新元组时，将会创建组合事务 ID。
- 组合事务 ID 位于pg_multixact目录中。
```
begin;
-- 查询当前事务id
select txid_current();
SELECT * FROM test0 WHERE i = 6 FOR SHARE;
-- 查询行锁事务id
SELECT xmin, xmax, cmin, cmax, * FROM test0;
commit;
```
| 事务 852                                  | 事务 853                                  | 事务854                                   | 事务855                                   | 说明                                                         |      |      |
| ----------------------------------------- | ----------------------------------------- | ----------------------------------------- | ----------------------------------------- | ------------------------------------------------------------ | ---- | ---- |
| SELECT * FROM test0 WHERE i = 6 FOR SHARE |                                           |                                           |                                           |                                                              |      |      |
|                                           | SELECT * FROM test0 WHERE i = 6 FOR SHARE |                                           |                                           | 此时，两个事务都锁定了该行。该行的`xmax`字段被设置为`1`，这是一个组合事务 ID。组合事务`1`根据事务 ID 指向事务`852`和`853`。 |      |      |
|                                           |                                           | SELECT * FROM test0 WHERE i = 6 FOR SHARE |                                           | 新增一个事务`854`锁定该行，此时该行的`xmax`字段被设置为`2`.即每当一个额外的事务想要锁定一行时， 都必须将整个新的组合事务写入到缓冲区。 |      |      |
|                                           |                                           | COMMIT;                                   |                                           | 事务`854`现在已结束，但该行的`xmax`值仍为`14`。由于组合事务是不可变的，因此组合事务`2`仍然会指向现已失效的事务`854`，以及正在进行中的事务`853`、`852`。 |      |      |
| COMMIT;                                   | COMMIT;                                   |                                           |                                           | 两个事务都结束后，在该行上不再有处于活动状态的锁。它的`xmax`值仍然是`2`，并且会一直保持为`2`，直到另一个进程锁定该行，或者该表被进行`VACUUM`。 |      |      |
|                                           |                                           |                                           | SELECT * FROM test0 WHERE i = 6 FOR SHARE | 此时，只有事`855`独占该行锁，此时的`xmax`为`855`             |      |      |
|                                           |                                           |                                           | COMMIT;                                   |                                                              |      |      |
## 锁
存储在共享内存池中，其大小由配置变量 max_locks_per_transaction 和 max_connections 定义  
若耗尽此内存，服务器将无法授予任何锁  
### 表级锁
- ACCESS SHARE  
每次执行 SELECT 查询时，相关的表上自动获取 ACCESS SHARE 锁，以确保数据读取过程中表的结构不发生变化。    
兼容性：ACCESS SHARE 锁之间不会相互阻塞，但它会阻止获取 ACCESS EXCLUSIVE 锁的操作（例如 DROP TABLE、TRUNCATE 或 ALTER TABLE 操作），以避免在读取表时被这些破坏性操作打断。
```
-- 事务1
begin;
select * from tmp1;
commit;

-- 事务2
begin;
alter table tmp1 add column age int;
commit;
```
![image](https://github.com/user-attachments/assets/9792ba58-1826-41b9-b8c3-820e73c925fc)

- ROW SHARE  
通常在执行操作如 SELECT ... FOR UPDATE 或 SELECT ... FOR SHARE 时被使用  
```

```
- ROW EXCLUSIVE  
对表执行数据修改操作时（如 INSERT、UPDATE、DELETE），该表自动加上 ROW EXCLUSIVE 锁。它不会阻止其他事务读取表数据或执行其他行级修改操作，但会防止一些表结构变更操作  

- SHARE  
由CREATE INDEX（不带CONCURRENTLY）获得。 

- SHARE ROW EXCLUSIVE   
由CREATE TRIGGER和某些形式的 ALTER TABLE所获得  

- SHARE UPDATE EXCLUSIVE   
由VACUUM（不带FULL）、ANALYZE、 CREATE INDEX CONCURRENTLY、REINDEX CONCURRENTLY、 CREATE STATISTICS以及某些ALTER INDEX 和 ALTER TABLE的变体获得 

- EXCLUSIVE  
由REFRESH MATERIALIZED VIEW CONCURRENTLY获得  

- ACCESS EXCLUSIVE  
由ALTER TABLE、DROP TABLE、TRUNCATE、REINDEX、CLUSTER、VACUUM FULL和REFRESH MATERIALIZED VIEW（不带CONCURRENTLY）命令获得。  

***锁冲突模式***
| 请求锁\已存在锁        | ACCESS SHARE | ROW SHARE | ROW EXCLUSIVE | SHARE UPDATE EXCLUSIVE | SHARE | SHARE ROW EXCLUSIVE | EXCLUSIVE | ACCESS EXCLUSIVE |
| ---------------------- | ------------ | --------- | ------------- | ---------------------- | ----- | ------------------- | --------- | ---------------- |
| ACCESS SHARE           |              |           |               |                        |       |                     |           | X                |
| ROW SHARE              |              |           |               |                        |       |                     | X         | X                |
| ROW EXCLUSIVE          |              |           |               |                        | X     | X                   | X         | X                |
| SHARE UPDATE EXCLUSIVE |              |           |               | X                      | X     | X                   | X         | X                |
| SHARE                  |              |           | X             | X                      |       | X                   | X         | X                |
| SHARE ROW EXCLUSIVE    |              |           | X             | X                      | X     | X                   | X         | X                |
| EXCLUSIVE              | X            | X         | X             | X                      | X     | X                   | X         | X                |
| ACCESS EXCLUSIVE       | X            | X         | X             | X                      | X     | X                   | X         | X                |

### 行级锁
事务可以在同一行上持有冲突的锁，即使在不同的子事务中也是如此；但除此之外，两个事务绝不能在同一行上持有冲突的锁。行级锁不会影响数据查询；它们只会阻止对同一行的写入者和锁定者  
- FOR UPDATE  
  任何在一行上的DELETE命令也会获得FOR UPDATE锁模式，在某些列上修改值的UPDATE也会获得该锁模式  
- FOR NO KEY UPDATE  
  和FOR UPDATE命令类似，但是对于获取锁的要求更加宽松一些，在同一行中不会阻塞SELECT FOR KEY SHARE命令。同样在UPDATE命令的时候如果没有获取到FOR UPDATE锁的情况下会获取到该锁  
- FOR SHARE  
  行为与FOR NO KEY UPDATE类似，不过它在每个检索到的行上获得一个共享锁而不是排他锁  
- FOR KEY SHARE  
  行为与FOR SHARE类似，不过锁较弱：SELECT FOR UPDATE会被阻塞，但是SELECT FOR NO KEY UPDATE不会被阻塞  

***锁冲突模式***
| 请求锁\已存在的锁 | FOR KEY SHARE | FOR SHARE | FOR NO KEY UPDATE | FOR UPDATE |
| ----------------- | ------------- | --------- | ----------------- | ---------- |
| FOR KEY SHARE     |               |           |                   | X          |
| FOR SHARE         |               |           | X                 | X          |
| FOR NO KEY UPDATE |               | X         | X                 | X          |
| FOR UPDATE        | X             | X         | X                 | X          |
