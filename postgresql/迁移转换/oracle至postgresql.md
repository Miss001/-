## 语法差异转换
|                                  | postgresql11                                                 | mysql8                                                       |
| -------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| group_concat                     | with<br/>t as(<br/>select 1 as i ,'a' as id<br/>union ALL<br/>select null as i,'a' as id<br/>union ALL<br/>select 2 as i,'b' as id<br/>union ALL<br/>select 3 as i,'b' as id<br/>)<br/>select string_agg(i::text,',' order by i)  from t  group by id | with<br/>t as(<br/>select 1 as i ,'a' as id<br/>union ALL<br/>select null as i,'a' as id<br/>union ALL<br/>select 2 as i,'b' as id<br/>union ALL<br/>select 3 as i,'b' as id<br/>)<br/>select group_concat(i SEPARATOR ',')  from t group by id |
| 尾部空格字符串（' '）            | 读取为空格字符串（' '）                                      | 当字符集排序规则的Pad_attribute='PAD SPACE'时，<br/>识别为：空字符串（''）,like 除外<br/>当字符集排序规则的Pad_attribute='NO PAD'时，<br/>识别为：空格字符串（' '） |
| uuid                             | select uuid_generate_v4()                                    | select uuid()                                                |
| ifnull                           | select coalesce(null,1)                                      | select ifnull(null,1)                                        |
| limit                            | select * from test limit 2 offset 0                          | select * from test limit 0,2                                 |
| if                               | SELECT   <br/>(CASE id     <br/>    WHEN 1 THEN '男'         <br/>   ELSE '女' END)<br/>FROM test | select if(id=1,'男','女') from test                          |
| str_to_date                      | select to_timestamp('2024-01-01 00:0:00','yyyy-mm-dd hh24:mi:ss') | select str_to_date('2024-01-01 00:0:00','%Y-%m-%d %H:%s:%i') |
| date_format                      | select to_char(current_timestamp,'yyyy-mm-dd hh24:mi:ss')    | select date_format(now(),'%Y-%m-%d %H:%s:%i')                |
| timestampdiff                    | select round(extract(EPOCH  from now() - to_timestamp('2024-01-01 00:00:00','yyyy-mm-dd hh24:mi:ss'))) | select timestampdiff(SECOND,str_to_date('2024-01-01 00:00:00','%Y-%m-%d %H:%s:%i'),now()) |
| interval                         | select now() + (1\|\|' day')::interval<br/>select now() + interval '1 DAY' | select  now() + interval 1 DAY                               |
| 伪劣排序                         | select row_number() over () as rowId from test               | select (@i:=@i+1) As rowId<br/>from test a,<br/>     (select @i := 0) b |
| replace into                     | insert into test (id,content)<br/>select 1,'tx'<br/>ON CONFLICT (id)<br/>DO UPDATE SET content = EXCLUDED.content | replace into test(id,content)<br/>select 1,'tx'              |
| insert … on duplicate key update | insert into test (id,content)<br/>select 1,'tx'<br/>ON CONFLICT (id)<br/>DO UPDATE SET content = EXCLUDED.content | INSERT INTO test (id, content) <br/>select * from(<br/>select 2 as id,'tx' as content<br/>)b<br/>ON DUPLICATE KEY <br/>UPDATE content=b.content |
| insert ignore                    | insert into test (id,content)<br/>select 3 ,'tx'<br/>ON CONFLICT (id)<br/>DO NOTHING | INSERT IGNORE INTO test(id, content) <br/>select 3 as id,'tx' as content |
| 多表关联更新                     | UPDATE <br/>    product p<br/>SET <br/>    net_price = p.price - p.price * s.discount,<br/>    segment_name=t.segment<br/>FROM <br/>    product_segment s,<br/>    segment t<br/>WHERE <br/>    p.segment_id = s.id<br/>    and s.segment=t.segment; | UPDATE <br/>    product p<br/>    JOIN product_segment s ON p.segment_id = s.id<br/>    JOIN segment t ON s.segment=t.segment<br/>SET <br/>    p.net_price = p.price - p.price * s.discount,<br/>    p.segment_name=t.segment |



|                          | postgresql17                                                 | oracle11                                                     |
| ------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| dual                     | select 1                                                     | select 1 from DUAL                                           |
| rownum                   | select row_number() over () as rownum, * from test；<br/>select * from test limit 2; | SELECT rownum,a.* FROM test a;<br/>SELECT * FROM test  WHERE ROWNUM < =2 ; |
| sys_guid                 | select replace(uuid_generate_v4()::text,'-','')              | select sys_guid() from dual                                  |
| nvl                      | COALESCE(NULL,'1')                                           | NVL(NULL,'1')                                                |
| instr                    | strpos('APP', 'P')                                           | INSTR('APP', 'P',1,1)                                        |
| decode                   | SELECT<br/>    (CASE id<br/>      WHEN 1 THEN 'Pending'<br/>      WHEN 2 THEN 'Paid'<br/>      WHEN 3 THEN 'Shipped'<br/>      ELSE 'Unknown'<br/>    END)as name<br/>FROM test | SELECT<br/>  DECODE(id,1,'Pending',2,'Paid',3 ,'Shipped','Unknown')as name<br/>FROM test |
| syddate                  | now() / current_timestamp                                    | SYSDATE                                                      |
| trunc(date)              | date_trunc('year', TIMESTAMP '2001-02-16 20:38:40')          | TRUNC(sysdate)                                               |
| months_between           | SELECT EXTRACT(YEAR FROM AGE('2024-01-17 14:45:30'::TIMESTAMP, '2023-10-01 00:00:00'::TIMESTAMP)) * 12 +<br/>       EXTRACT(MONTH FROM AGE('2024-01-17 14:45:30'::TIMESTAMP, '2023-10-01 00:00:00'::TIMESTAMP))+<br/>       EXTRACT(DAY FROM AGE('2024-01-17 14:45:30'::TIMESTAMP, '2023-10-01 00:00:00'::TIMESTAMP)) /30<br/>       AS months_difference; | select MONTHS_BETWEEN(to_date('2024-01-17 14:45:30','yyyy-mm-dd hh24:mi:ss'),<br/>                      to_date('2023-10-01 00:00:00','yyyy-mm-dd hh24:mi:ss')) <br/>  from dual |
| add_months               | select now(),now() + (1\|\|' month')::interval               | select ADD_MONTHS(sysdate, 1) from dual                      |
| last_day                 | SELECT DATE_TRUNC('MONTH', now()) + <br/>       INTERVAL '1 MONTH - 1 DAY' AS last_day; | select LAST_DAY(trunc(sysdate)) from dual                    |
| 时间相减（天）           | select extract(EPOCH  from now() - to_timestamp('2023-01-01','yyyy-mm-dd'))/86400 | select sysdate - to_date('2023-01-01','yyyy-mm-dd') from dual |
| 时间加减（天）           | select CURRENT_TIMESTAMP,CURRENT_TIMESTAMP + (1\|\|' day')::interval | select sysdate+1 from dual                                   |
| chr(0)                   | chr(0) 是作为结束符来处理的，不允许作为用户输入传入字符串中  | chr(0)代表空字符                                             |
| 空字符串（''）           | 读取为 空字符串('')<br/>select * from test where content='' -- 有结果集 | 读取为 NULL<br/>select * from test where content='' -- 无结果集 |
| 尾部空格字符串（' '）    | 读取为空格字符串（' '）                                      | 读取为空格字符串（' '）                                      |
| NULL值与非NULL值字符拼接 | 结果为：NULL                                                 | 结果为：非NULL值                                             |
| 递归查询                 | with recursive a as(<br/>  -- 第一个子句只执行一次。<br/>  select id,parent_id,username ,1 as recursion_level <br/>      from tmp3 where parent_id is NULL<br/>  union ALL<br/>  -- 第二个子句是迭代逻辑生效的地方<br/>  select b.id,b.parent_id,b.username, a.recursion_level +1<br/>      from tmp3 b join a on a.id=b.parent_id<br/>)<br/>select id,parent_id,username,recursion_level from a | select id, parent_id ,level as recursion_level<br/>from tmp3  start with parent_id IS NULL<br/>  connect by prior id = parent_id |
| 分层查询                 | SELECT "DATE"<br/>  FROM generate_series(timestamp '2010-01-01',<br/>                       timestamp '2010-02-01',<br/>                       interval '1 day') s("DATE"); | SELECT to_date('2010-01-01','yyyy-mm-dd') + level - 1<br/>FROM dual<br/>CONNECT BY LEVEL <= to_date('2010-02-01','yyyy-mm-dd') - to_date('2010-01-01','yyyy-mm-dd') + 1; |
| (+)进行外连接            | SELECT *<br/>FROM<br/>   tmp2 b<br/>RIGHT OUTER JOIN tmp1 a ON b.id = a.user_id | SELECT *<br/>FROM<br/>  tmp1 a,<br/>  tmp2 b<br/>WHERE<br/>  b.id (+)= a.user_id |
| MERGE 操作               | MERGE INTO users A<br/>USING (<br/>SELECT 'jane_doe' AS username, '111@example.com' AS email, now() AS last_login<br/>)B<br/>ON A.username = B.username<br/>WHEN MATCHED THEN<br/>    UPDATE SET email = B.email, last_login = B.last_login<br/>WHEN NOT MATCHED THEN<br/>    INSERT (username, email, last_login)<br/>        VALUES (B.username, B.email, B.last_login); | MERGE INTO users A<br/>USING (<br/>    SELECT 'jane_doe' AS username, '111@example.com' AS email, SYSDATE AS last_login<br/>    FROM dual<br/>) B<br/>ON (A.username = B.username)<br/>WHEN MATCHED THEN<br/>    UPDATE SET A.email = B.email, A.last_login = B.last_login<br/>WHEN NOT MATCHED THEN<br/>    INSERT (username, email, last_login)<br/>    VALUES (B.username, B.email, B.last_login); |
| 多表关联更新             | UPDATE <br/>    product p<br/>SET <br/>    net_price = p.price - p.price * s.discount,<br/>    segment_name=t.segment<br/>FROM <br/>    product_segment s,<br/>    segment t<br/>WHERE <br/>    p.segment_id = s.id<br/>    and s.segment=t.segment | UPDATE product p<br/>SET (net_price, segment_name)= <br/>     (select t.segment, p.price - p.price * s.discount<br/>           from product_segment s, segment t <br/>           where s.segment=t.segment and p.segment_id = s.id)<br/>WHERE EXISTS(select 1<br/>           from product_segment s, segment t <br/>           where s.segment=t.segment and p.segment_id = s.id) |
| listagg distinct         | with<br/>t as(<br/>select 1 as i ,'a' as id<br/>union ALL<br/>select 1 as i ,'a' as id<br/>union ALL<br/>select null as i,'a' as id<br/>union ALL<br/>select 2 as i,'b' as id<br/>union ALL<br/>select 3 as i,'b' as id<br/>union ALL<br/>select 10 as i,'b' as id<br/>)<br/>select array_to_string(array_agg(distinct i order by i asc), ',')<br/>from t  <br/>group by id | with<br/>t as(<br/>select 1 as i ,'a' as id from dual<br/>union ALL<br/>select 1 as i ,'a' as id from dual<br/>union ALL<br/>select null as i,'a' as id from dual<br/>union ALL<br/>select 2 as i,'b' as id from dual<br/>union ALL<br/>select 3 as i,'b' as id from dual<br/>union ALL<br/>select 10 as i,'b' as id from dual<br/>)<br/>select listagg(i,',') within group (order by i asc) <br/>from (select distinct * from t) group by id |
| wm_concat(distinct)      | with<br/>t as(<br/>select 1 as i ,'a' as id<br/>union ALL<br/>select 1 as i ,'a' as id<br/>union ALL<br/>select null as i,'a' as id<br/>union ALL<br/>select 2 as i,'b' as id<br/>union ALL<br/>select 3 as i,'b' as id<br/>union ALL<br/>select 10 as i,'b' as id<br/>)<br/>select string_agg(distinct i::text,',' order by i::text asc )  from t  group by id | with<br/>t as(<br/>select 1 as i ,'a' as id from dual<br/>union ALL<br/>select 1 as i ,'a' as id from dual<br/>union ALL<br/>select null as i,'a' as id from dual<br/>union ALL<br/>select 2 as i,'b' as id from dual<br/>union ALL<br/>select 3 as i,'b' as id from dual<br/>union ALL<br/>select 10 as i,'b' as id from dual<br/>)<br/>select wm_concat(distinct i) <br/>from t group by id |
| nologging                | create unlogged table test1 as<br/>select * from test limit 10 | create table test1 nologging as<br/>select * from test where rownum<=10 |
