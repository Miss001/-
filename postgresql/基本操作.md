## 索引设置
CREATE INDEX CONCURRENTLY 允许在不锁定表的情况下创建索引，从而允许其他并发操作继续进行。  
CREATE INDEX CONCURRENTLY 不能在事务块（transaction block）中执行  
### 类型
- B-Tree （默认）  
  只有B-tree 能够被声明为唯一    
  适用于所有的数据类型，支持排序，支持等值或范围或模糊匹配的搜索。  
- Hash  
  哈希索引项只存储每个索引项的哈希代码，而不是实际的数据值.只支持等值查询。  
- GiST  
  即通用的搜索树(Generalized Search Tree)，适用于多维数据类型和集合数据类型。    
  和Btree索引相比，Gist多字段索引在查询条件中包含索引字段的任何子集都会使用索引扫描，而Btree索引只有查询条件包含第一个索引字段才会使用索引扫描。    
- SP-GiST  
  SP代表空间分区（space partitioning），适用于范围是否相交，是否包含，地理位置中的点面相交，或者按点搜索附近的点的搜索。  
- GIN  
  适用于多值类型，例如数组、全文检索、TOKEN的搜索等。  
- BRIN  
  块级索引，适用于时间或序列字段创建，进行等值、范围查询。  
### 方式
- 唯一索引  
  强制列值的唯一性，或多个列的组合值的唯一性。
```
CREATE UNIQUE INDEX idx_tmp1_user_id ON tmp1 (user_id);
```
- 表达式索引  
  根据表中一个或多个列计算出的函数或标量表达式
```
CREATE INDEX idx_tmp1_low_username ON tmp1 (lower(username));
```
- 部分索引  
  在表的一个子集上构建的索引，作用：以排除无意义的值。
```
CREATE INDEX idx_tmp1_price ON tmp1 (price) WHERE createdtime is not null;
```

## 主键设置
- 1.使用 SERIAL/BIGSERIAL 数据类型 自增主键  
本质是基于一个序列（sequence）来生成唯一的递增值，PostgreSQL 在执行 INSERT 语句时，会在插入数据之前生成并分配该序列的下一个值。
当插入操作失败时，例如由于违反约束（如唯一约束或其他业务逻辑错误），序列的值已被消费，但数据未被插入，这就会导致序列跳过了一个值。
```
CREATE TABLE tmp1 (
    user_id BIGSERIAL PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    price NUMERIC(10, 2) NOT NULL,
    createdtime TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```
- 2.使用 IDENTITY 列 自增主键  
当列被定义为 GENERATED ALWAYS 时，数据库始终自动为该列生成递增的值。即使用户在插入语句中为该列提供了值，也会被忽略，数据库将用自动生成的值替代用户提供的值。  
当列被定义为 GENERATED BY DEFAULT 表示当用户没有为该列提供值时，数据库将自动生成递增的值。如果用户提供了值，数据库将使用用户提供的值而不是自动生成的值。  
```
CREATE TABLE tmp1 (
    user_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    price NUMERIC(10, 2) NOT NULL,
    createdtime TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```
- 3.使用 自定义序列 自增主键  
``` 
创建序列
CREATE SEQUENCE user_id_seq;
ALTER SEQUENCE user_id_seq INCREMENT BY 1;
创建表
CREATE TABLE tmp1 (
    user_id INT DEFAULT nextval('user_id_seq') PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    price NUMERIC(10, 2) NOT NULL,
    createdtime TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```
- 4.uuid 主键  
```
CREATE TABLE tmp1 (
    user_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    username VARCHAR(50) NOT NULL,
    price NUMERIC(10, 2) NOT NULL,
    createdtime TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

## 语句块
```
do $$ 
declare
  cur_ CURSOR FOR select user_id from tmp1;
  v_sql text;
begin
   for i in cur_ LOOP
    begin
     /*
       insert into tmp2
          select user_id from tmp1 where user_id=i.user_id;
      */
      v_sql :='insert into tmp2 select user_id from tmp1 where user_id='''||i.user_id||'''';
      EXECUTE v_sql;
    
      EXCEPTION 
     WHEN others THEN
       RAISE NOTICE 'Error occurred: SQLSTATE: %, Message: %', SQLSTATE, SQLERRM;

    end;
    END LOOP;

end $$;
```
## 自定义函数创建
```
create or replace function get_name(v_id uuid)
returns varchar
language plpgsql
as
$$
declare
  v_sql text;
  res varchar(100);
begin
     select username into res from tmp1 where user_id=v_id;
       -- 成功时返回结果
     return res;
     
    EXCEPTION
    WHEN OTHERS THEN
       RAISE NOTICE 'Error occurred: SQLSTATE: %, Message: %', SQLSTATE, SQLERRM;
        return NULL;

end $$;
```

## 存储过程创建
存储过程的子事务不能直接提交
```
CREATE OR REPLACE PROCEDURE p_template()
LANGUAGE plpgsql
AS $$
/*
create table tj_log(
id varchar(36),
task_name varchar(30),
task_desc text,
begin_time timestamp,
end_time timestamp,
bz text
)
*/
DECLARE
  v_id varchar(36);
  v_err text;
  cur_ CURSOR FOR select user_id from tmp1;
    
BEGIN
  v_id :=uuid_generate_v4();
  
  insert into tj_log(id,task_name,task_desc,begin_time,end_time)
    values(v_id,'p_template','存储过程测试',CURRENT_TIMESTAMP,null);

-- ----------------------------------------logic-----------------------------------------------
for i in cur_ LOOP
     insert into tmp2
        select user_id from tmp1 where user_id=i.user_id;
END LOOP;

-- --------------------------------------------------------------------------------------------
UPDATE tj_log SET end_time=CURRENT_TIMESTAMP,bz='完成' WHERE task_name='p_template' AND id=v_id;

EXCEPTION
    -- 捕获其他类型的错误并记录日志
    WHEN others THEN
        v_err :=SQLSTATE ||'-'||SQLERRM;
        UPDATE tj_log SET end_time=CURRENT_TIMESTAMP,bz=v_err WHERE task_name='p_template' AND id=v_id;
        RAISE NOTICE 'Error occurred: SQLSTATE: %, Message: %', SQLSTATE, SQLERRM;
COMMIT;

END;
$$;

```

## 视图创建
 更新视图时，不支持删除视图中的现有列和修改列的排列顺序，只允许在现有列的末尾添加附加列。
 需要修改列的顺序、删除列等，需要先` drop view view_name` 后再创建。
```
create or replace view v_tmp1 
as
select user_id, username,price ,createdtime from tmp1
```

## 复杂函数使用
