## 主键设置
### 1.使用 SERIAL/BIGSERIAL 数据类型 自增主键
本质是基于一个序列（sequence）来生成唯一的递增值，PostgreSQL 在执行 INSERT 语句时，会在插入数据之前生成并分配该序列的下一个值。
当插入操作失败时，例如由于违反约束（如唯一约束或其他业务逻辑错误），序列的值已被消费，但数据未被插入，这就会导致序列跳过了一个值。
```
CREATE TABLE tmp1 (
    user_id BIGSERIAL PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    price NUMERIC(10, 2) NOT NULL,
    createdtime TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```
### 2.使用 IDENTITY 列 自增主键
当列被定义为 GENERATED ALWAYS 时，数据库始终自动为该列生成递增的值。即使用户在插入语句中为该列提供了值，也会被忽略，数据库将用自动生成的值替代用户提供的值。  
当列被定义为 GENERATED BY DEFAULT 表示当用户没有为该列提供值时，数据库将自动生成递增的值。如果用户提供了值，数据库将使用用户提供的值而不是自动生成的值。  
```
CREATE TABLE tmp1 (
    user_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    price NUMERIC(10, 2) NOT NULL,
    createdtime TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```
### 3.使用 自定义序列 自增主键
```
创建序列
CREATE SEQUENCE user_id_seq;
ALTER SEQUENCE user_id_seq INCREMENT BY 1;
创建表
CREATE TABLE tmp1 (
    user_id INT DEFAULT nextval('user_id_seq') PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    price NUMERIC(10, 2) NOT NULL,
    createdtime TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

## uuid 主键
```
CREATE TABLE tmp1 (
    user_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    username VARCHAR(50) NOT NULL,
    price NUMERIC(10, 2) NOT NULL,
    createdtime TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```
## 语句块
```

```
## 自定义函数创建
```

```

## 存储过程创建
存储过程的子事务不能直接提交
```
CREATE OR REPLACE PROCEDURE p_template()
LANGUAGE plpgsql
AS $$
/*
create table tj_log(
id varchar(36),
task_name varchar(30),
task_desc text,
begin_time timestamp,
end_time timestamp,
bz text
)
*/
DECLARE
  v_id varchar(36);
  v_err text;
  cur_ CURSOR FOR select user_id from tmp1;
    
BEGIN
  v_id :=uuid_generate_v4();
  
  insert into tj_log(id,task_name,task_desc,begin_time,end_time)
    values(v_id,'p_template','存储过程模板',CURRENT_TIMESTAMP,null);

-- ----------------------------------------logic-----------------------------------------------
for i in cur_ LOOP
     insert into tmp2
        select user_id from tmp1 where user_id=i.user_id;
END LOOP;

-- --------------------------------------------------------------------------------------------
UPDATE tj_log SET end_time=CURRENT_TIMESTAMP,bz='完成' WHERE task_name='p_template' AND id=v_id;

EXCEPTION
    -- 捕获其他类型的错误并记录日志
    WHEN others THEN
        v_err :=SQLSTATE ||'-'||SQLERRM;
        UPDATE tj_log SET end_time=CURRENT_TIMESTAMP,bz=v_err WHERE task_name='p_template' AND id=v_id;
        RAISE NOTICE 'Error occurred: SQLSTATE: %, Message: %', SQLSTATE, SQLERRM;
COMMIT;

END;
$$;

```
