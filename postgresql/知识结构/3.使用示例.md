## 主键设置
- 1.使用 SERIAL/BIGSERIAL 数据类型 自增主键  
本质是基于一个序列（sequence）来生成唯一的递增值，PostgreSQL 在执行 INSERT 语句时，会在插入数据之前生成并分配该序列的下一个值。    
当插入操作失败时，例如由于违反约束（如唯一约束或其他业务逻辑错误），序列的值已被消费，但数据未被插入，这就会导致序列跳过了一个值。  
通常使用BIGSERIAL 而不是 SERIAL。
```
CREATE TABLE tmp1 (
    user_id BIGSERIAL PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    price NUMERIC(10, 2) NOT NULL,
    createdtime TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```
- 2.使用 IDENTITY 列 自增主键  
当列被定义为 GENERATED ALWAYS 时，数据库始终自动为该列生成递增的值。即使用户在插入语句中为该列提供了值，也会被忽略，数据库将用自动生成的值替代用户提供的值。   
当列被定义为 GENERATED BY DEFAULT 表示当用户没有为该列提供值时，数据库将自动生成递增的值。如果用户提供了值，数据库将使用用户提供的值而不是自动生成的值。    
要求：所有插入都必须从默认序列中获取值，若插入任意值会报错  
```
CREATE TABLE tmp1 (
    user_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    price NUMERIC(10, 2) NOT NULL,
    createdtime TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```
- 3.使用 自定义序列 自增主键  
``` 
创建序列
CREATE SEQUENCE user_id_seq;
ALTER SEQUENCE user_id_seq INCREMENT BY 1;
创建表
CREATE TABLE tmp1 (
    user_id INT DEFAULT nextval('user_id_seq') PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    price NUMERIC(10, 2) NOT NULL,
    createdtime TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```
- 4.uuid 主键  
  缺点：随机写入不同位置的各页面，因此必须将更多的页面引入内存和更多的缓存未命中、占用空间是BIGSERIAL两倍的空间。  
```
CREATE TABLE tmp1 (
    user_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    username VARCHAR(50) NOT NULL,
    price NUMERIC(10, 2) NOT NULL,
    createdtime TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

## 匿名块创建
```
DO $$ 
DECLARE
  cur_ CURSOR IS SELECT user_id FROM tmp1;
  v_sql text;
BEGIN
   for i in cur_ LOOP
    BEGIN
     /*
       insert into tmp2
          select user_id from tmp1 where user_id=i.user_id;
      */
      v_sql :='insert into tmp2 select user_id from tmp1 where user_id='''||i.user_id||'''';
      EXECUTE v_sql;
      EXCEPTION 
     WHEN others THEN
       RAISE NOTICE 'Error occurred: SQLSTATE: %, Message: %', SQLSTATE, SQLERRM;
    END;
    END LOOP;
END $$;
```
## 自定义函数创建
```
CREATE OR REPLACE FUNCTION get_name(v_id uuid)
RETURNS varchar
LANGUAGE plpgsql
AS
$$
DECLARE
  v_sql text;
  res varchar(100);
BEGIN
     select username into res from tmp1 where user_id=v_id;
       -- 成功时返回结果
     return res;
     
    EXCEPTION
    WHEN OTHERS THEN
       RAISE NOTICE 'Error occurred: SQLSTATE: %, Message: %', SQLSTATE, SQLERRM;
        return NULL;
END $$;
```

## 存储过程创建
存储过程运行在一个事务上下文中，其子事务不能直接提交。  
如果发生错误，默认情况下，整个事务将会回滚，包括之前成功执行的所有语句。
```
CREATE OR REPLACE PROCEDURE p_template()
LANGUAGE plpgsql
AS $$
/*
create table tj_log(
id varchar(36),
task_name varchar(30),
task_desc text,
begin_time timestamp,
end_time timestamp,
bz text
)
*/
DECLARE
  v_id varchar(36);
  v_err text;
  v_begin_time timestamp;
  cur_ CURSOR IS SELECT user_id FROM tmp1;
    
BEGIN
  v_id :=uuid_generate_v4();
  v_begin_time :=now();
  
-- ----------------------------------------logic-----------------------------------------------
  for i in cur_ LOOP
    BEGIN
     insert into tmp2
        select * from tmp1 where user_id=i.user_id;
     END;
  END LOOP;

-- --------------------------------------------------------------------------------------------
INSERT INTO tj_log(id,task_name,task_desc,begin_time,end_time,bz)
 VALUES(v_id,'p_template','存储过程测试',v_begin_time,now(),'完成');
 
EXCEPTION
    WHEN OTHERS THEN        
        v_err := format('Error occurred: SQLSTATE: %s, Message: %s', SQLSTATE, SQLERRM);
        
        INSERT INTO tj_log(id,task_name,task_desc,begin_time,end_time,bz)
        VALUES(v_id,'p_template','存储过程测试',v_begin_time,now(),v_err);
        
        -- RAISE NOTICE 'Error occurred: SQLSTATE: %, Message: %', SQLSTATE, SQLERRM;
        
COMMIT;
END;
$$;
```

## 视图创建
 更新视图时，不支持删除视图中的现有列和修改列的排列顺序，只允许在现有列的末尾添加附加列。
 需要修改列的顺序、删除列等，需要先` drop view view_name` 后再创建。
```
create or replace view v_tmp1 
as
select user_id, username,price ,createdtime from tmp1
```

## 分区表创建
```
CREATE TABLE tmp4 (
    id serial,
    name text,
    code varchar,
    dates timestamp
) PARTITION BY RANGE (dates);
-- 创建主键
ALTER TABLE tmp4 ADD PRIMARY KEY (id, dates,code);

-- 为2024年1月的数据创建按code列表分区
CREATE TABLE tmp4_p202401 PARTITION OF tmp4
    FOR VALUES FROM ('2024-01-01 00:00:00') TO ('2024-02-01 00:00:00')
    PARTITION BY LIST (code);
CREATE TABLE tmp4_p202401_0000 PARTITION OF tmp4_p202401
    FOR VALUES IN ('0000');
CREATE TABLE tmp4_p202401_1111 PARTITION OF tmp4_p202401
    FOR VALUES IN ('1111');

-- 为2024年2月的数据创建按code列表分区
CREATE TABLE tmp4_p202402 PARTITION OF tmp4
    FOR VALUES FROM ('2024-02-01 00:00:00') TO ('2024-03-01 00:00:00')
    PARTITION BY LIST (code);
CREATE TABLE tmp4_p202402_0000 PARTITION OF tmp4_p202402
    FOR VALUES IN ('0000');
CREATE TABLE tmp4_p202402_1111 PARTITION OF tmp4_p202402
    FOR VALUES IN ('1111');
    
CREATE TABLE tmp4_p202401_default PARTITION OF tmp4_p202401 DEFAULT;
CREATE TABLE tmp4_p202402_default PARTITION OF tmp4_p202402 DEFAULT;
CREATE TABLE tmp4_p_default PARTITION OF tmp4 DEFAULT;

```
## 递归查询(with recursive)
```
drop table tmp3;
create table tmp3(
id    int,
parent_id  int,
username  varchar(100)
);

insert into tmp3 values(1,null,'A');
insert into tmp3 values(2,1,'B');
insert into tmp3 values(3,1,'B');
insert into tmp3 values(4,1,'D');
insert into tmp3 values(5,2,'E');
insert into tmp3 values(6,4,'F');
insert into tmp3 values(7,5,'G');
commit; 

with recursive a as(
  -- 第一个子句只执行一次。
  select id,parent_id,username ,1::integer recursion_level 
      from tmp3 where parent_id is NULL
  union ALL
  -- 第二个子句是迭代逻辑生效的地方
  select b.id,b.parent_id,b.username, a.recursion_level +1
      from tmp3 b join a on a.id=b.parent_id
)
select id,parent_id,username,recursion_level from a
```

## 插入更新
- INSERT INTO ...ON CONFLICT
```
INSERT INTO users (username, email, last_login)
VALUES ('jane_doe', '111@example.com', NOW())
ON CONFLICT (username)
DO UPDATE SET email = EXCLUDED.email, last_login = EXCLUDED.last_login;
```
- MERGE INTO
```
MERGE INTO users a
USING (
SELECT 'jane_doe' AS username, '111@example.com' AS email, now() AS last_login
) AS b
ON a.username = b.username
WHEN MATCHED THEN
    UPDATE SET email = b.email, last_login = b.last_login
WHEN NOT MATCHED THEN
    INSERT (username, email, last_login)
        VALUES (b.username, b.email, b.last_login);
```
