## 主键设置
- 1.使用 SERIAL/BIGSERIAL 数据类型 自增主键  
本质是基于一个序列（sequence）来生成唯一的递增值，PostgreSQL 在执行 INSERT 语句时，会在插入数据之前生成并分配该序列的下一个值。
当插入操作失败时，例如由于违反约束（如唯一约束或其他业务逻辑错误），序列的值已被消费，但数据未被插入，这就会导致序列跳过了一个值。
```
CREATE TABLE tmp1 (
    user_id BIGSERIAL PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    price NUMERIC(10, 2) NOT NULL,
    createdtime TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```
- 2.使用 IDENTITY 列 自增主键  
当列被定义为 GENERATED ALWAYS 时，数据库始终自动为该列生成递增的值。即使用户在插入语句中为该列提供了值，也会被忽略，数据库将用自动生成的值替代用户提供的值。  
当列被定义为 GENERATED BY DEFAULT 表示当用户没有为该列提供值时，数据库将自动生成递增的值。如果用户提供了值，数据库将使用用户提供的值而不是自动生成的值。  
```
CREATE TABLE tmp1 (
    user_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    price NUMERIC(10, 2) NOT NULL,
    createdtime TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```
- 3.使用 自定义序列 自增主键  
``` 
创建序列
CREATE SEQUENCE user_id_seq;
ALTER SEQUENCE user_id_seq INCREMENT BY 1;
创建表
CREATE TABLE tmp1 (
    user_id INT DEFAULT nextval('user_id_seq') PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    price NUMERIC(10, 2) NOT NULL,
    createdtime TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```
- 4.uuid 主键  
```
CREATE TABLE tmp1 (
    user_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    username VARCHAR(50) NOT NULL,
    price NUMERIC(10, 2) NOT NULL,
    createdtime TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

## 语句块
```
do $$ 
declare
  cur_ CURSOR FOR select user_id from tmp1;
  v_sql text;
begin
   for i in cur_ LOOP
    begin
     /*
       insert into tmp2
          select user_id from tmp1 where user_id=i.user_id;
      */
      v_sql :='insert into tmp2 select user_id from tmp1 where user_id='''||i.user_id||'''';
      EXECUTE v_sql;
    
      EXCEPTION 
     WHEN others THEN
       RAISE NOTICE 'Error occurred: SQLSTATE: %, Message: %', SQLSTATE, SQLERRM;

    end;
    END LOOP;

end $$;
```
## 自定义函数创建
```
create or replace function get_name(v_id uuid)
returns varchar
language plpgsql
as
$$
declare
  v_sql text;
  res varchar(100);
begin
     select username into res from tmp1 where user_id=v_id;
       -- 成功时返回结果
     return res;
     
    EXCEPTION
    WHEN OTHERS THEN
       RAISE NOTICE 'Error occurred: SQLSTATE: %, Message: %', SQLSTATE, SQLERRM;
        return NULL;

end $$;
```

## 存储过程创建
存储过程的子事务不能直接提交
```
CREATE OR REPLACE PROCEDURE p_template()
LANGUAGE plpgsql
AS $$
/*
create table tj_log(
id varchar(36),
task_name varchar(30),
task_desc text,
begin_time timestamp,
end_time timestamp,
bz text
)
*/
DECLARE
  v_id varchar(36);
  v_err text;
  cur_ CURSOR FOR select user_id from tmp1;
    
BEGIN
  v_id :=uuid_generate_v4();
  
  insert into tj_log(id,task_name,task_desc,begin_time,end_time)
    values(v_id,'p_template','存储过程测试',CURRENT_TIMESTAMP,null);

-- ----------------------------------------logic-----------------------------------------------
for i in cur_ LOOP
     insert into tmp2
        select user_id from tmp1 where user_id=i.user_id;
END LOOP;

-- --------------------------------------------------------------------------------------------
UPDATE tj_log SET end_time=CURRENT_TIMESTAMP,bz='完成' WHERE task_name='p_template' AND id=v_id;

EXCEPTION
    -- 捕获其他类型的错误并记录日志
    WHEN others THEN
        v_err :=SQLSTATE ||'-'||SQLERRM;
        UPDATE tj_log SET end_time=CURRENT_TIMESTAMP,bz=v_err WHERE task_name='p_template' AND id=v_id;
        RAISE NOTICE 'Error occurred: SQLSTATE: %, Message: %', SQLSTATE, SQLERRM;
COMMIT;

END;
$$;

```

## 视图创建
 更新视图时，不支持删除视图中的现有列和修改列的排列顺序，只允许在现有列的末尾添加附加列。
 需要修改列的顺序、删除列等，需要先` drop view view_name` 后再创建。
```
create or replace view v_tmp1 
as
select user_id, username,price ,createdtime from tmp1
```

## 分区表创建
### 范围分区（RANGE）
```
CREATE TABLE tb_range_partitioned(
    id SERIAL,
    name TEXT,
    created_at DATE
) PARTITION BY RANGE (created_at);

ALTER TABLE tb_range_partitioned ADD PRIMARY KEY (id, created_at);

-- 创建第一个分区，存储 2024 年 1 月 的数据
CREATE TABLE range_partitioned_202401 PARTITION OF tb_range_partitioned
    FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');
-- 创建第二个分区，存储 2024 年 2 月 的数据
CREATE TABLE range_partitioned_202402 PARTITION OF tb_range_partitioned
    FOR VALUES FROM ('2024-02-01') TO ('2024-03-01');

INSERT INTO tb_range_partitioned (name, created_at)
VALUES ('John Doe', '2024-01-01');
INSERT INTO tb_range_partitioned (name, created_at)
VALUES ('Mike Doe', '2024-01-03');
INSERT INTO tb_range_partitioned (name, created_at)
VALUES ('Jane', '2024-02-01');

```
## 递归查询(with recursive)
```
drop table tmp3;
create table tmp3(
id    int,
parent_id  int,
username  varchar(100)
);

insert into tmp3 values(1,null,'A');
insert into tmp3 values(2,1,'B');
insert into tmp3 values(3,1,'B');
insert into tmp3 values(4,1,'D');
insert into tmp3 values(5,2,'E');
insert into tmp3 values(6,4,'F');
insert into tmp3 values(7,5,'G');
commit; 

with recursive a as(
  -- 第一个子句只执行一次。
  select id,parent_id,username ,1::integer recursion_level 
      from tmp3 where parent_id is NULL
  union ALL
  -- 第二个子句是迭代逻辑生效的地方
  select b.id,b.parent_id,b.username, a.recursion_level +1
      from tmp3 b join a on a.id=b.parent_id
)
select id,parent_id,username,recursion_level from a
```

## 插入更新
```
INSERT INTO users (username, email, last_login)
VALUES ('jane_doe', '111@example.com', NOW())
ON CONFLICT (username)
DO UPDATE SET email = EXCLUDED.email, last_login = EXCLUDED.last_login;
```
```
MERGE INTO users a
USING (
SELECT 'jane_doe' AS username, '111@example.com' AS email, now() AS last_login
) AS b
ON a.username = b.username
WHEN MATCHED THEN
    UPDATE SET email = b.email, last_login = b.last_login
WHEN NOT MATCHED THEN
    INSERT (username, email, last_login)
        VALUES (b.username, b.email, b.last_login);
```
